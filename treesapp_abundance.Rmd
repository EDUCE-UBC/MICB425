# Calculating relative abundance of meta'omic data

## Introduction and goals

Genome assemblies contain less information than the sequence reads and recovering it is not always possible.
The shotgun DNA sequencing technique samples subsequences from the genomes that comprise a microbial community. Sequencing bias, while present, is subtle enough that we can assume that each subsequence's frequency in the reads approximates its abundance in the underlying community. Whenever a (meta)genome is assembled from reads, however, sequences that are tricky to assemble (due to repetitive motifs or low coverage) are removed and the abundance information is effectively lost.
One way to recover these read-level abundances is by aligning the reads back to the contigs and calculating the number of reads that mapped to each. One can go a step further still and use relative abundance normalization measures popular in transcriptomics, such as fragments per kilobase per million mappable reads (FPKM) or transcripts per million (TPM) @Wagner.2012.

TreeSAPP's subcommand `abundance` is capable of calculating FPKM or TPM for all classified query sequences. These can be derived from the reads in the FASTQ files of multiple different samples. This is only possible when the input fasta are nucleotide sequences from which ORFs were predicted within the pipeline (i.e. this thisn't possible with amino acid sequences).

The goal of this tutorial is to show you how to use `treesapp abundance` to calculate TPM for metagenome-derived ORF sequences.

## Workflow description

The workflow employed by TreeSAPP is common to many bioinformatics pipelines:

1.  Collect nucleotide sequences for the classified ORFs.
2.  BWA @Li.2013 creates an index from these nucleotide sequences - this will be the reference database.
3.  Align the short reads to the reference database with BWA MEM.
4.  Calculate the relative abundance metrics. TreeSAPP uses [samsum](https://github.com/hallamlab/samsum).

There are potentially two common use cases for `treesapp abundance`.

1.  Through `treesapp assign` where a single sample's read data are mapped to its corresponding assembly (i.e. contigs or scaffolds) and the relative abundances of these sequences are obtained.
2.  A combined assembly was generated from multiple samples, classified with `treesapp assign`, then the reads of each sample were mapped individually to generate sample-specific relative abundance values with `treesapp abundance`.

## Usage

There are two required arguments for `treesapp abundance`:

1.  **treesapp_output**: Path to the output directory from `treesapp assign`.
2.  **reads**: Path to a FASTQ file containing single-end reads, or foward mates or interleaved reads from a paired-end sequencing library.

Below are descriptions for the most important options:

1.  **reverse**: Path to a FASTQ file containing reverse mates from a paired-end sequencing library.
2.  **report**: This argument controls what `treesapp abundance` does with the resulting abundance values. The '*nothing*' option is most applicable to the Python API, and is used by `treesapp assign` to simply return the abundance object instances. '*update*' can be used when the abundance values in the classification table should be replaced with these newly calculated values. '*append*' should be used when reads of new samples are being used to calculate abundance (e.g. reads from a time-course experiment).
3.  **metric**: Either Fragments per Kilobase per Mllion mappable reads (FPKM) or Transcripts per Million (TPM).

## Outputs

The sole output of `treesapp abundance` is an edited classification table, previously generated by `treesapp assign`. No new files are generated, beyond intermediate files (e.g. SAM files). The values are in the 'Abundance' field of `final_outputs/marker_contig_map.tsv`.

## Tutorial steps

-   Connect to your group's server, then move to the directory `/data/ts_tutorial`.

```{bash eval = FALSE}
cd /data/ts_tutorial/
```

This tutorial requires many fastq and fasta formatted files, that are subsetted versions of the originals. They were created by searching metagenome assemblies and reads for XmoA then pulling out all sequences that matched into new files. We are going to save them in a new directory to keep `ts_tutorial` organized.

-  Create a new directory called `SI072_data` and download the data to it.

```{bash eval=F}
mkdir SI072_data
cd SI072_data
wget https://raw.githubusercontent.com/EDUCE-UBC/MICB425/cml-dev/data/SI072_abundance_files.txt
wget -i SI072_abundance_files.txt
```

We can move back out into the `/data/ts_tutorial/` directory again to run the TreeSAPP commands.

```{bash eval=F}
cd ..
```

We will begin by classifying XmoA sequences found in the metagenome contigs.

-  Assign taxonomic labels to Saanich Inlet metagenomic contigs using the updated XmoA refpkg with `treesapp assign`.

```{bash eval=FALSE}
treesapp assign \
  -n 4 \
  --trim_align \
  --refpkg_dir XmoA_MAG_update/final_outputs/ \
  --fastx_input SI072_data/SI072_MetaG_contigs.fasta \
  --output SI072_MetaG_contigs_XmoA_assign/
```



```{bash eval=FALSE}
treesapp abundance \
  -n 4 \
  --treesapp_output SI072_MetaG_contigs_XmoA_assign/ \
  --reads SI072_data/SI072_*m_pe.1.fq.gz \
  --reverse SI072_data/SI072_*m_pe.2.fq.gz \
  --report update \
  --metric tpm
```



```{bash eval=FALSE}
treesapp abundance \
 -n 4 \
 --treesapp_output SI072_MetaG_contigs_XmoA_assign/ \
 --reads SI072_data/SI072_*m_MetaT_QC_Filtered.fastq.gz \
 --pairing pe \
 --metric tpm \
 --report append
```



```{bash eval=FALSE}
treesapp layer \
 -o SI072_MetaG_contigs_XmoA_assign/ \
 --refpkg_dir XmoA_MAG_update/final_outputs/ \
 -c XmoA_colours/XmoA_Function_colours_style.txt
```


## Use your group's reference package to calculate abundances

Continue to work with your group's reference package in the directory `/data/<gene name>`. Visualize the appropriate outputs with iTOL.
